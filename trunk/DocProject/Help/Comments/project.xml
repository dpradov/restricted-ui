<?xml version="1.0" encoding="utf-8"?>
<doc>
  <members>
    <member name="R:Project">
      <remarks>
        <span lang="ES-MODERN">
          <p>
            <strong>Licencia</strong>
          </p>
          <span lang="ES-MODERN">
            <p>RestrictedUI: MOZILLA PUBLIC LICENSE STATEMENT.<br />----------------------------------------------------------<br /> The contents of this file are subject to the Mozilla Public<br /> License Version 1.1 (the "License"); you may not use this file<br /> except in compliance with the License. You may obtain a copy of<br /> the License at <a href="http://www.mozilla.org/MPL/">http://www.mozilla.org/MPL/</a></p>
            <p> Software distributed under the License is distributed on an "AS<br /> IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or<br /> implied. See the License for the specific language governing<br /> rights and limitations under the License.</p>
            <p> The Original Code is RestrictedUI 1.0.</p>
            <p> The Initial Developer of the Original Code is Daniel Prado Velasco<br /> &lt;<a href="mailto:dpradov@gmail.com">dpradov@gmail.com</a>&gt; (Spain).<br /> Portions created by Daniel Prado Velasco are<br /> Copyright (C) 2010. All Rights Reserved.<br /> -----------------------------------------------------------<br /> Contributor(s):<br /> -----------------------------------------------------------<br /> History:<br /> -----------------------------------------------------------<br /> Released: 04 April 2010<br /> -----------------------------------------------------------<br /> URLs:<br />  <a href="http://code.google.com/p/restricted-ui/">http://code.google.com/p/restricted-ui/</a><br /></p>
          </span>
        </span>
      </remarks>
      <summary>
        <div class="issueDetail">
          <div style="MARGIN: 0px 0px -3px" align="left">
            <img border="0" hspace="0" alt="" align="baseline" src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/IconRestrictedUI.gif" /> <a style="COLOR: rgb(0,0,0); TEXT-DECORATION: none" href="http://code.google.com/p/restricted-ui/">restricted-ui</a>: <i><a style="COLOR: rgb(0,0,0); TEXT-DECORATION: none" id="project_summary_link" href="http://code.google.com/p/restricted-ui/">.NET Library to restrict user interface based on security policy</a></i></div>
          <div> </div>
          <div> </div>
        </div>
        <div class="issueDetail">
          <strong>Namespaces </strong>
        </div>
        <see cref="N:RestrictedUI">RestrictedUI</see>  <see cref="N:RestrictedWebUI">RestrictedWebUI</see>  <see cref="N:RestrictedWinFormsUI">RestrictedWinFormsUI</see>  <see cref="N:RestrictedWinFormsUI_Infragistics">RestrictedWinFormsUI_Infragistics</see>  
<div style="FONT-STYLE: italic; MARGIN-TOP: 3px"> </div><div style="FONT-STYLE: italic; MARGIN-TOP: 3px"> </div><div style="FONT-STYLE: italic; MARGIN-TOP: 3px"><strong>Tutorial</strong></div><p><ul><li>1. Introduction 
<ul><li>Key Features</li></ul><li>2. Using the code 
<ul><li>2.1. Main entities 
<ul><li>ControlRestrictedUI 
<li>ControlRestrictedUIWeb 
<li>ControlRestrictedUIWinForms 
<li>IControlAdapter 
<li>IControlAdapterFactory 
<li>UIRestrictions 
<li>RestrictionOnControl 
<li>IHost 
<li>SecurityEnvironment</li></li></li></li></li></li></li></li></li></ul><li>2.2. Example usage 
<ul><li>Security policy maintenance: FrmRestrictionsUIDefinition</li></ul><li>2.3. Test projects</li></li></li></ul><li>3. Points of Interest </li></li></li></ul><p> </p><p> </p><h1><a name="1._Introducción">1. Introduction</a></h1><p>A delicate part in the implementation of applications's security, specially corporate applications, is to determine which functionalities must or not be accessible to the user depending on his role, or which elements should or should not be shown.</p><p>It is usual to include in the code logic to hide or disable certain options, buttons, etc, depending on the user accessing the application. This can get complicated when apart from the type of user should also be considered the state of the application, such as the processing status of an entity.<br />Also, it is quite usual that this policy should be changed with some frequency, in the same way that should must evolve the application requirements. Due to changes in the organizational structure of the company, modifications in management protocols or simply the identification of gaps after the use of the application, among other things, would be necessary to make adjustments to this logic related to the interface.</p><p>In response to this problem it is also possible to centralize the definition of this policy, in a common repository for multiple applications. Based on this definition, supported by a particular data model, you can define a library used by the applications that makes it possible to modify the security policy without having to recompile and redeploy applications. The main idea is that the programmer develops as if there were only one type of user, administrator, with permission to do anything. It is the library that controls whether an attempt should be prevented from making visible certain controls or enable them.</p><p>This approach is currently used in the company where I work. While offering great flexibility in design, it's concrete implementation presents, from my point of view, a number of constraints and practical difficulties that I have tried to correct with this other library / framework:</p><p><a name="1._Introducción" /> </p><h2>Key Features</h2><p>On the one hand the library / architecture described here does not require to centralize the definition of this security, but it's seen as a case; secondly, to ensure compliance with these interface restrictions it is not necessary to require the programmer to use specific methods or properties of the library, to check if the change is allowed or not, nor has to be controlled by any code; simply any attempt to make visible or enabled any interface element supervised not allowed by the security policy is intercepted and prevented. By default, it is only supervised the attempt of making visible or enabled the control, but it can be configured to monitor also the 'deactivation' of that properties, that is, the attempt to make invisible or disabled the control.</p><p>It is allowed to define restrictions policy not only on the basis of roles but also on the application states, in both WinForms and Web applications; and to simplify the definition of this policy a form of maintenace is provided, available both at design time and runtime. </p><p><a name="Características_principales">Notes: </a></p><ul><li>It isn't objective of this library to control user authentication. It is assumed that this is done correctly and it is known, with guarantees, the role or roles that the user holds. 
<li>The name of the library, RestrictedUI refers to the fact that certain elements of the interface will be restricted according to established security ('Restricted area')<a name="Características_principales"><li>This library is available in Google Code: <a href="http://code.google.com/p/restricted-ui">http://code.google.com/p/restricted-ui</a>. You can check out the source code from the project's Subversion repository. There you will have documentation and binaries to download, and the posibility to report issues. It is also included a revision documented in spanish</li></a></li></li></ul><p><a name="Características_principales"><br /><br /></a></p><h1><a name="2._Usando_el_código">2. Using</a> the code</h1><p>I will describe now in detail this code:<a name="2._Usando_el_código" /></p><h2><a name="2.1._Entidades_principales">2.1. Main entities</a></h2><p><a name="2.1._Entidades_principales"><br /><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/modelo1.gif" /></a></p><p><a name="2.1._Entidades_principales"><br /><br /></a></p><p><a name="2.1._Entidades_principales"><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/modelo2.gif" /></a></p><a name="2.1._Entidades_principales"><p><br />The main classes and with wich the programmer will primarily interact are fundamentally: <font face="Courier New"><see cref="T:RestrictedUI.ControlRestrictedUI">ControlRestrictedUI</see></font> (through some specific components that are offered either for WinForms as for Web), <font face="Courier New"><see cref="T:RestrictedUI.SecurityEnvironment">SecurityEnvironment</see></font> and <font face="Courier New"><see cref="T:RestrictedUI.IHost">IHost</see></font>. </p><p>The first contains most of the business logic, and is responsible for ensuring the UI security in the control where it is, relying on other classes.</p><p>The second, <font color="#990000">SecurityEnvironment</font>, is a Singleton object that lets you configure aspects that are common to all components and makes it possible to massively set security for all or part of the components (necessary for loading restrictions from a centralized repository).</p><p>The third, <font color="#990000">IHost</font>, is the interface that should provide the application that makes use of this library and will let know the status of the application and the user role or roles.</p><p>Constrictions policy that apply to a <font color="#990000">ControlRestrictedUI</font> component are stored in the form of an <u><font color="#008000">UIRestrictions</font></u> object and this in turn contains a list of restrictions (permissions and prohibitions), which are only structures <u><font color="#008000">RestrictionOnControl</font></u>. These two entities are described below with a little more detail and along with them how to define security policy. </p><p>In case that it is needed to work with controls that are not already considered or some of them need to be managed differently, it will be necessary to create the corresponding adapters (<u><font color="#008000">IControlAdapter</font></u>) along with the factory that generate them (<u><font color="#008000">IControlAdapterFactory</font></u>). All that has to be done in these cases is to develop a new DLL that includes the new adapters required and the corresponding factory. This factory will be added to the <font color="#990000">SecurityEnvironment</font> object, as explained in the example described below. You can create these adapters and factories basing them on those already available. </p><p> </p><p>Clasess and methods more noteworthy are:</p></a><font color="#000000" size="3"><p /></font><h4>ControlRestrictedUI</h4><p>Base component of the Restricted Interface library (RestrictedUI): can restrict the visibility and enabling state of the controls included in a form or user control based on a definition of established security, involved the current state of the application in the form or container as well as the role or roles of the user of the application.</p><ul><li><font color="#990000">ID</font>, <font color="#990000">InstanceID</font> - Identifier of the component and the specific instance. From the <font color="#990000">ID</font> it can be read / updated the security definition from a file, to be established at an environment level. With these two attributes the <font color="#990000">IHost</font> object will indicate the status and roles that apply, distinguishing not only on type of form but on specific instance.<br /><li><font color="#990000">RestrictionsDefinition</font> - Configuration of the prohibitions and permissions to be set.<br /><li><font color="#990000">ConfigFile</font> - Gets or sets the path to a configuration file, to be used primarily at design time.<br />The configuration file makes it possible to provide at design time and for the definition of security in the form <font color="#990000">FrmRestrictionsUIDefinition</font> the list of roles and states to use, as well as additional control adapters factories, so to 'discover' new controls at design time. The own definitions of security restrictions, of all or only some components may be contained in this file. These restrictions can be loaded at runtime using the method <font color="#990000">LoadFrom</font>() and saved and loaded at will from <font color="#990000">FrmRestrictionsUIDefinition</font> form, at design time or runtime.<br /><li><font color="#990000">ControlsFile</font> - Name of the file on wich can be written the list of the controls contained in the form or user control controlled by this component.<br />This file makes it possible to offer at design time controls from the form <font color="#990000">FrmRestrictionsUIDefinition</font> to be created dynamically. For Web applications it necessarily must be used to configure security at design time with the help of that form.<br /><li><font color="#990000">RegisterControls</font> - Forces the record or update of the existing controls on the form or container where this <font color="#990000">ControlRestrictedUI</font> component is embedded.<br /><li><font color="#990000">BeforeApplyingRestriction</font> - Occurs just before permitting or preventing the change of <font color="#990000">Visible</font> or <font color="#990000">Enabled</font> property, to give the option to allow or not the change on the basis of a more complex logic.<br /><li><font color="#990000">ChangeAllowed</font> - It is the method that assesses the restrictions policy and decides whether to allow a certain change in a control. It checks if the change on <font color="#990000">Visible</font> or <font color="#990000">Enabled</font> property (or the corresponding on the control) is valid considering the definition of security, user roles and the current state of the application.<br /><li><font color="#990000">VerifyChange</font> - Checks if the change on the specified property (<font color="#990000">TChange</font>) is valid considering the definition of security, user roles and the current state of the application. If the change is invalid will be undone, this is, set again to <font color="#990000">False</font>. Control adapters call this method of the security component in response to the attempt to change the monitored properties.<br /><li><font color="#990000">SuperviseDeactivation</font> - It determines if the restrictions will be applied also in the 'deactivation' of the controls (supervising the attempt of making a control invisible or disabled), not only in the activation.<br /></li></li></li></li></li></li></li></li></li></ul><p><br /></p><h4>ControlRestrictedUIWeb</h4><p>Adaptation, for Web applications, of the <font color="#990000">ControlRestrictedUI</font> component.</p><p><br /></p><h4>ControlRestrictedUIWinForms</h4><p>Adaptation, for WinForms applications, of the <font color="#990000">ControlRestrictedUI</font> component.</p><p><br /></p><h4>IControlAdapter</h4><p>Wraps a 'control' with the aim of providing an uniform access to its <font color="#990000">Enabled</font> and <font color="#990000">Visible</font> properties and its 'controls' son, also allowing to provide oversight of the change of these properties, giving option to prevent such changes based on a security scheme. What the adapter wraps needs not to be an object of a particular class, it can be anything that the adapter 'understands', on which it is possible and interesting to control the visibility and or enabled state, and that an adapter 'father' has recognized it as a son.</p><p>Actually controlled properties need not be exactly '<font color="#990000">Visible</font>' and '<font color="#990000">Enabled</font>'; it is the responsibility of the control adapter to offer that interface and to act on the properties that the control has (for example, some controls do not offer <font color="#990000">Enabled</font> but <font color="#990000">ReadOnly</font>)</p><p>The controls provided in the maintenance of security form (<font color="#990000">FrmRestrictionsUIDefinition</font>) and the controls where the component <font color="#990000">ControlRestrictedUI</font> seeks are those offered as 'children' for the control in which is embedded the component. The adapter for this parent control will be asking to their child controls' adapters, which will discover new controls. So, if you have an adapter that understand controls DataGridView, for example, it is possible to provide each of the columns as a child to monitor. Thus, the number of controls to monitor depends on the adapters with which to work, and this depends in turn on the factories that have been incorporated:</p><p><br /></p><h4>IControlAdapterFactory</h4><p>Defines an external factory of control adapters. These will be consulted before the base factory (internal) when it comes to locating the adapter to be used.</p><p>It only defines the following method: <font color="#990000">GetAdapter</font>. Returns the most suitable adapter for the control that is being passed, according to the factory. If the factory has no proper adapter for this control, it will return the special adapter <font color="#990000">NullControlAdapter</font>.</p><p><br /></p><h4>UIRestrictions</h4><p>It contains all the interface restrictions (UI) (permissions and prohibitions) that define security for a <font color="#990000">ControlRestrictedUI</font> component, and that therefore they usually involve a form or user control.</p><p>All restrictions apply to individual controls, bearing in mind that the prohibitions will take precedence over permissions, that is, permissions will be aplied first and then restricted on the basis of the prohibitions:</p><li>Prohibitions: only will be prevented changes to the property <font color="#990000">Visible</font> / <font color="#990000">Enabled</font> in the situations outlined here. 
<li>Permissions: only will be authorized changes to the property <font color="#990000">Visible</font> / <font color="#990000">Enabled</font> in the situations outlined here. 
<p>This class saves individual restrictions (see <font color="#990000">RestrictionOnControl</font>) and determines if they should be considered in positive logic (permissions) or negative logic (prohibitions). It is responsible for serializing and deserializing these permissions.</p><p><br /></p><h4>RestrictionOnControl</h4><p>It defines the elements that make up a particular restriction to monitor. This restriction will only have its full meaning when read in conjunction with other restrictions included in a security policy defined in a <font color="#990000">UIRestrictions</font> object and managed by a <font color="#990000">ControlRestrictedUI</font> component.</p><p>The elements which form an individual restriction are: 
<ul><li>The control to be monitored (via an adapter) 
<li>The properties to be monitored (<font color="#990000">Visible</font> and/or <font color="#990000">Enabled</font>) 
<li>The context of the application for which the restriction is defined: 
<ul><li>Rol or roles of the application user 
<li>State or states of the application</li></li></ul></li></li></li></ul><p><p>These elements may be applied in positive logic (permissions) or negative (prohibitions). This interpretation is not offered by this entity, but by <font color="#990000">UIRestrictions</font> depending on whether this restriction has been placed in a line of permissions or prohibitions.</p><ul><li>If the restriction is a permission, it will indicate that the supervised properties can only be 'activated' (make visible or enable) by the established roles and only when the application is in the established states. 
<li>If the restriction is a prohibition, it will indicate that the supervised properties can only be 'activated' (make visible or enable) by the established roles when the application is in the mentioned states. For any other combination of roles / state the activation will be possible. 
<li>If no role is provided (by default, role is assumed = 0) then it will apply to all roles: all of them will be allowed or prevented (depending) in the indicated states. 
<li>If no state is provided, then the restriction will apply to all concerning roles, regardless of the state in which the application is. 
<li>If a control has no associated restriction element (neither positive nor negative) then it will not be monitored, and any role and in any state could activate its Visible and Enabled properties.</li></li></li></li></li></ul><p>Actually controlled properties in the control need not be exactly '<font color="#990000">Visible</font>' and '<font color="#990000">Enabled</font>' (as shown in <font color="#990000">IControlAdapter</font>).  </p><p><p><p>By default, it is only supervised and perhaps prevented (depending on the policy defined) the 'activation' of the properties, namely the attempt to make visible or enabled the control. It is not prevented to make invisible or disabled a control. With the property <font color="#990000">SuperviseDeactivation </font><font color="#000000">(in <font color="#990000">ControlRestrictedUI </font>component) it is possible to change that general behaviour and monitor also the 'deactivation' of the controls, allowing or preventing it according to the security definition.</font></p></p></p></p></p></li><p>It is also possible to indicate a list of controls for which the attempt of making it invisible or disabled should or not be supervised, and so it may or not be prevented (independently of the value of that <font color="#990000">SuperviseDeactivation </font><font color="#000000">property.</font><br /></p><h4>IHost</h4><p>It indicates that the object can act as intermediary in the necessary communication between the Host and the Restricted Interface library, enabling it to view at any time the application status and the role or roles that may have the user. It also reports through events of changes to these values.</p><p>These data (state and roles) may be dependent on the form or user control from which we are asking (type and specific instance).</p><p>This approach allows, for example, keep different instances of a particular window open, each one in a state or a different processing stage and therefore with different security requirements. While it is more common that the user role or roles should be uniform throughout the application, they are also allowed to depend on where you place the security component and the specific instance. This will give more leeway when configuring the security.</p><p><br /></p><h4>SecurityEnvironment</h4><p>Singleton class (via Shared) that keeps general aspects to all security scheme.</p><ul><li><font color="#990000">Host</font> - Gets or sets the object that implements the interface <font color="#990000">IHost</font> and through which the environment and other security components may interact with the Host application in order to know the current status and roles to be considered.<br /><li><font color="#990000">LoadFrom</font>, <font color="#990000">LoadFromString</font> - They let you load the security policy (for all or a subset of security components) from a file, a stream or a text string, at environment level.<br /><li><font color="#990000">CommonStates</font>, <font color="#990000">CommonRoles</font> - They allow to establish the common roles and states that are offered in all security components.<br /><li><font color="#990000">ComponentsSecurity</font> - It returns the dictionary object which stores the definition of security (policy interface constraints) of the various components, as may have been established from the load of a configuration file or a text string.<br />The security herein needs not be equal to the embedded in the various components. The restrictions finally applied in the component depend on one of its properties (<font color="#990000">PriorityEmbeddedSecurity</font>). Methods like <font color="#990000">LoadFrom</font> or <font color="#990000">LoadFromString</font>, for example, will establish on the <font color="#990000">SecurityEnvironment</font> the restrictions to apply to each of the components that are referenced in the file or string (even with an empty definition), and set the indicated property so that the components use that restrictions.<br /><li><font color="#990000">GetAdapter</font> - Returns the adapter (<font color="#990000">IControlAdapter</font>) for the indicated control, based on registered factories in the <font color="#990000">SecurityEnvironment</font>.<br /><li><font color="#990000">BaseFactory</font>, <font color="#990000">AditionalFactories</font> - Gets or sets the adapter factory considered as base, as well as additional ones. When it comes to finding the best control adapter it will start looking for it in the additional ones and finally in the base factory if none is found before.<br /><li><font color="#990000">AddFactoria</font> - Adds the specified factory of control adapters. It will be consulted earlier than the internal factory.<br /></li></li></li></li></li></li></li></ul><p><br /><br /></p><h3>Example Usage</h3><p>It is necessary to include a reference to the dlls <font color="#990000">RestrictedUI.dll</font> and <font color="#990000">RestrictedWebUI.dll</font> or <font color="#990000">RestrictedWinFormsUI.dll</font>, depending on the type of application. If you include in your application some special controls that you want to address in a personalized way then you will add a reference to the corresponding DLL, which will have implemented a factory of adapters for that particular control. The following example uses a library that interprets the controls of Infragistics <font color="#990000">UltraGrid</font> and <font color="#990000">UltraTree</font> (NetAdventage).</p><p>At the beginning of the application we do the following initialization. Only the first line is really important:</p><pre lang="vbnet">' Initial setup of the security library:
'-----------------------------------------

' We set the object IHost that will reveal the status and roles of the application
SecurityEnvironment.Host = _host

' We don't want config files to be automatically updated on the initialization of the security components.
' We will update them when we have created all the controls (some of them will be build dynamically: datagrid columns)
SecurityEnvironment.AutomaticUpdateOfControlsFile = False

' Because we use Infragistics controls and they are not covered by internal factory included with the library
' ControlRestrictedUIWinForms, we will record the factory that manages them       
SecurityEnvironment.AddFactory(AdapterInfragisticsWinForms_Factory.getInstance)

' Some adapters like these can allow to control the enabled state with the ReadOnly property instead of Enabled
' (the latter would be the default)
AdapterWinForms_DataGridView.UseReadOnly = True
AdapterInfragisticsWinForms_UltraGrid.UseReadOnly = True

' Apart from that we have defined some security policy embedded in a component, we will use the one defined in a file
' (We could also have read the security from a stream providing a System.IO.StreamReader, or directly from a string 
' with EntornoSeguridad.LoadFromString)
SecurityEnvironment.LoadFrom("TestWinForms\Security.txt")
</pre><p>Below is a sample configuration file that can be loaded by <font color="#990000">LoadFrom</font>.</p><p>The object _host would be of the class Host, which would implement the interface <font color="#990000">IHost</font>, for example like this (TestForm):</p><pre lang="vbnet">Public Class Host
    Implements IHost

    Public Event StateChanged(ByVal ID As String, ByVal instanceID As String, ByVal newState As Integer) Implements RestrictedUI.IHost.StateChanged
    Public Event RolesChanged(ByVal ID As String, ByVal instanceID As String) Implements RestrictedUI.IHost.RolesChanged

    Public Sub ShowError(ByVal [error] As String) Implements IHost.ShowError
       ' There are controls that are dynamically created and it is common not to locate them in the event HandleCreated (if WinForms)
        If [error].Contains("Control not found") Then
            If [error].Contains("cControles.") Then
                Exit Sub
            End If
        End If

        MessageBox.Show([error])
    End Sub


    ' In this implementation, the state may be different depending on the component and instance.
    Public Property State(ByVal ID As String, ByVal instanceID As String) As Integer Implements RestrictedUI.IHost.State
        Get
            Dim nState As Integer = 0
            _State.TryGetValue(ID + instanceID, nState)
            Return nState
        End Get
        Set(ByVal value As Integer)
            _State.Remove(ID + instanceID)
            _State.Add(ID + instanceID, value)
            RaiseEvent StateChanged(ID, instanceID, value)
        End Set
    End Property
    Private _State As New Dictionary(Of String, Integer)


    ' In this implementation, the roles that we refer will be the same regardless of the form or the instance
    Public Property UserRoles(ByVal ID As String, ByVal instanceID As String) As Integer() Implements RestrictedUI.IHost.UserRoles
        Get
            Return _userRoles
        End Get
        Set(ByVal value As Integer())
            _userRoles = value
            RaiseEvent RolesChanged(ID, instanceID)
        End Set
    End Property
    Private _userRoles As Integer() = New Integer(1) {10, 11}

End Class</pre><p>Although in the <font color="#990000">IHost</font> interface the properties <font color="#990000">State</font> and <font color="#990000">UserRoles</font> have not been set as <font color="#990000">ReadOnly</font>, the reading of these properties is the most important thing. The change in state or roles will be used (if allowed) to test security from the maintenance form. If it is not necessary, the implementation of the modification (set) can be left empty.</p><p>We will add a <font color="#990000">ControlRestrictedUI</font> component for every form or user control in wich we want to apply a restrictions policy. The configuration of this component is usually made at design time. As an example (looking at it through the code generated by the Designer):</p><pre lang="vbnet">'ControlRestrictedUIWinForms1
'
Me.ControlRestrictedUIWinForms1.ConfigFile = "TestWinForms\Security.txt"
Me.ControlRestrictedUIWinForms1.ControlsFile = "TestWinForms\Controls.txt"
Me.ControlRestrictedUIWinForms1.ID = "Form1"
Me.ControlRestrictedUIWinForms1.InstanceID = "00"
Me.ControlRestrictedUIWinForms1.ParentControl = Me
Me.ControlRestrictedUIWinForms1.Paused = False
Me.ControlRestrictedUIWinForms1.RestrictionsDefinition = New String() {
  "$Group 0= GroupBox1.CheckBox1, GroupBox1.TextBox2",
  "$Group 2= TextBox",
  "+0/GroupBox1.CheckBox1,E,0", "+99/Combo,V"}
</pre><p>Roles alias are not used in the constraints defined directly on the component, not depending thus on any translation table.</p><p>Apart from that configuration, we can add the following code at the beginning of the form or container, for example in the <font color="#990000">Load</font> event:</p><pre lang="vbnet">' If we want the application to be able to determine a state and independent role or roles for each instance of a 
' form, so that we can open several ones simultaneously and these ones may have independent lives, then we must identify each instance:
 ControlRestrictedUIWinForms1.InstanceID = _InstanceID

' If we have created controls dynamically then we can update the controls file (if we are developing we might want
' to be allowed to establish security over controls available only in runtime)
#If DEBUG Then
  ' To update the controls file and thus be able to consider those controls when editting the security in design time.
   ControlRestrictedUIWinForms1.RegisterControls()
#End If

' In any case, if we dynamically created controls they will not have been localized when security initializes.
' So we will force a reinitilization of the security:
 ControlRestrictedUIWinForms1.ReinitializeSecurity()
</pre><p>Security can be set directly at environment level for all or only a selection of components using a text string, for example contained in a file, similar to the following:</p><pre> 
[Factories]
; Relative paths will be expressed in relation to the folder containing the solution (. sln). This path will be 
; used to locate the DLL in design time. We will assume that the DLL is in the same folder as the executable, 
; so in runtime the path will be ignored and used only the name of the file
; Note: You may also use absolute paths.
TestWinForms\bin\Debug\RestrictedWinFormsUI_Infragistics.dll, RestrictedWinFormsUI_Infragistics.AdapterInfragisticsWinForms_Factory

[CommonRoles]
99,Administrator,Adm
10,Director,Dtor
20,Consultant,Cons

[CommonStates]
0,Initial
1,Pending Validating
2,Validated

;=======================================================
[SECURITYCONTROL=Form1]
[Roles]
30,Auxiliar,Aux

[States]
3,Special State

[Groups]
Group Disable Buttons= gbCommands.btnDisableEnabled, gbCommands.btnDisableVisible
Group Enabled Buttons= gbCommands.btnEnableEnabled, gbCommands.btnEnableVisible, gbCommands.btnEnableVisible_N
Group Trees= TreeView1, UltraTree1

[Restrictions]
#Yes=TextBox,$Group Trees
#No=GroupBox1.CheckBox1
+123/TextBox,V,2
+Adm/$Group Trees,E/MenuStrip1.EditarToolStripMenuItem.CortarToolStripMenuItem,V
+Dtor/GroupBox1.CheckBox1,V
-0/MenuStrip1.ArchivoToolStripMenuItem.NuevoToolStripMenuItem,E/ToolStrip1.ToolStripComboBox1,E/ToolStrip1.ToolStripSplitButton1,E
-Aux/cControles.Name,V,1,2,3/$Group Enabled Buttons,V
-Cons/combo,V/$Group Disable Buttons,E

;=======================================================
[SECURITYCONTROL=Form2_Sub1]
[Roles]

[States]

[Groups]
Grupo 0= CheckBox1, TextBox1
Grupo 1 - nuevo grupo= Button1, TextBox1

[Restrictions]
+0/$Grupo 0,E
-0/CheckBox1,E/Button1,E
</pre><p><p><p>Through this feature you can store security restrictions in a centralized repository, for example a relational database and then retrieve and apply them at the beginning of the application. This way we can modify the restrictions without recompiling applications.</p><p>In the definition to be loaded into the <font color="#990000">SecurityEnvironment</font>, for instance from a file, roles alias can be used to define restrictions, because it is assumed that they are described in the same file. Anyway, when it is applied to the security component they are translated into their corresponding codes.</p><p>You must keep in mind that the use of aliases is entirely optional, and the definition of lists of states and roles too. They are nothing more than a help to facilitate the identification of constraints. All that matters is that the codes of the roles and application states are understood by the application through the object that implements the interface <font color="#990000">IHost</font>.</p><p>When calling <font color="#990000">SecurityEnvironment.LoadFrom</font> or <font color="#990000">LoadFormString</font>, the restrictions defined in the file or text string will take precedence over the ones embedded in the components. If in that text string there is no section relative to a particular component it will continue to apply the security embedded in that component. If you would like to remove all restrictions from a component it would be enough to include an empty paragraph related to that component:</p><pre>;=======================================================
[SECURITYCONTROL=Form3]

;=======================================================
[SECURITYCONTROL=Form4]
[Restrictions]
-0/CheckBox1,E/Button1,E
 </pre><h3>Security policy maintenance: FrmRestrictionsUIDefinition</h3><p>Settings directly embedded in the component or through configuration files similar to above, can be generated with the maintenance form included, and easily modified by hand if necessary. This form is accessible both at design time and runtime. At design time you can access it by clicking on the button '...' in the property <font color="#990000">RestrictionsDefinition</font> of a component <font color="#990000">ControlRestrictedUI</font>; at runtime using the method <font color="#990000">ShowConfigurationSecurityForm</font> and also directly by pressing a key combination ready for it by means of <font color="#990000">SecurityEnvironment.AllowedHotKey</font> (disabled by default)</p><p><br /><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/frmrestrictionsuidefinition.gif" /></p><p>Basically what we can do is to select (checkbox) one or more controls, the property or properties to be monitored (<font color="#990000">Visible</font>, <font color="#990000">Enabled</font>) and optionally one or more roles together with one or more states. Pressing the button 'Allow' a new restriction (positive) will be added, related to that selection. Clicking on 'Prevent' a negative restriction will be added.</p><p>We can define groups of controls, with an associated name, and place restrictions directly to the group. To add or update an existing group we will mark a series of controls and click Add. It will ask us for a name for the group. If it already exists it will be replaced by the new selection, otherwise it will be added.<br />By selecting one or another group will be selecting in the controls's grid the elements in the group. When you checked the box 'Show only selected Group' then clicking on Allow or Prevent, the restriction is directly associated to the corresponding group.</p><p>We have the option of saving the restrictions in a configuration file, being added to the restrictions that may already exist for other components. This file will be initially the one established (if any) for the component. We can read the security settings of the component from which we have launched this form, or all that may be included in the file.</p><p>We have for convenience two ways of displaying the permissions: tabular or text, both editable.</p><p><br /><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/frmRestrictionsUIDefinition_text.gif" /></p><p><br />From this text view, it is also posible to indicate controls with an explicit treatment of the 'deactivation' supervision: controls for which the attempt of making it invisible or disabled should or not be supervised (#Yes=... or #No=...), and so it may or not be prevented. </p><p>If we use this form at runtime we can also double click a control to highlight it (it will blink several times). We will also have the possibility to modify (if the object implementing <font color="#990000">IHost</font> interface permits it) the state and the role or roles associated to this component and instance, so that we can test security. For convenience we can reduce this form to offer only these controls:</p><p><br /><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/frmrestrictionsuidefinition_reduced.gif" /><br /></p><h2>Test projects</h2><p>Along with the solution three projects are included, two on WinForms and another one on Web: <font color="#990000">TestWeb</font>, <font color="#990000">TestWinForms</font> and <font color="#990000">TestWinForms_notUsingInfragistics</font>.</p><p>The two projects in WinForms are equivalent with the only difference that the latter does not use any control NetAdventage of Infragistics; library of UI controls used in the company I work and that I have included to demonstrate the use of additional factories to deal with special controls.</p><p>WinForm examples include a form (Form1) with which you can play with all the features of this library, including the possibility to pause the security, force visibility or enabled state for a control, or apply a more elaborate logic with the help of <font color="#990000">BeforeApplyingRestriction</font> event. The form Form1 in <font color="#990000">TestWinForms</font> is as follows:</p><p><br /><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/TestForm1.gif" /></p><p>And <font color="#990000">Form2</font>:</p><p><img src="file:///D:/PROYECTOS/restricted-ui/DocProject/Help/Art/TestForm2.gif" /></p><p>This second form allows you to verify the treatment of security on user controls: the tabs 1 and 2 have an embedded user control on which a series of restrictions has been applied that make editable only the text box. The tabs 3 and 4 include other user control whose security policy hides a node of the <font color="#990000">TreeView</font> control.</p><p>Apart from such specific restriction on the second user control, the security component of this form, <font color="#990000">Form2</font>, applies a restriction on the user control instance of the tab 4 so that the second radiobutton is disabled.</p><p>Both on <font color="#990000">Form1</font> as on <font color="#990000">Form2</font> the key combination CTR-ALT-End is enabled to show at runtime the form <font color="#990000">FrmRestrictionsUIDefinition</font>.</p><p><br /></p><h2>Points of Interest</h2><ul><li><p>When developing this code I found interesting to discover the possibilities offered by this type of code "injection" that is able to control or influence the Host application without having to make changes to it (except of course for the normal configuration of the library). This approach has been used to act on a pair of common properties of controls, <font color="#990000">Visible</font> and <font color="#990000">Enabled</font> (by preventing its activation according to a security policy), but it could be used in many other cases.</p><li><p>The pattern Indirection through <font color="#990000">IControlAdapter</font> interface, has been essential in achieving this goal, and it is very powerful. Using it with Factory pattern has also been very convenient.<br />The use of these two patterns has led to the extensibility of this architecture, allowing to add new libraries that would offer a personalized treatment of certain controls.</p><li><p>Although it might seem something minor it is interesting to note the use of Special Case pattern, as described by Martin Fowler in <a href="http://martinfowler.com/eaaCatalog/specialCase.html">P of EAA: Special Case</a> and the clear advantages affecting the code. This pattern is being used by the object <font color="#990000">NullControlAdapter</font>.</p><li><p>During the development of the component <font color="#990000">ControlRestrictedUI</font> I had difficulty with the fact that the properties set at design time were initialized by the Designer in alphabetical order. The initialization of the security in a component is done by setting the property <font color="#990000">RestrictionsDefinition</font>, but at that moment, in its setting by Designer, other required properties were not established. The solution to this problem is provided by the interface <font color="#990000">ISupportInitialize</font> (<a href="http://en.csharp-online.net/Design-Time_Integration%E2%80%94Batch_Initialization">Design-Time Integration—Batch Initialization</a>) </p><li><p>It has also been very comfortable and clean the use of <font color="#990000">INotifyPropertyChanged</font> interface to ensure proper bidirectional data link (DataBindings) between user controls and business entities (<a href="http://www.claassen.net/geek/blog/2007/07/generic-asynchronous.html">A generic asynchronous INotifyPropertyChanged helper</a>)</p><li><p>A major difficulty of this development has been associated with the component's design time . It was specially problematic the dynamic instantiation of objects <font color="#990000">IControlAdapterFactory</font> at design time, which caused exceptions <font color="#990000">InvalidCastException</font>.<br />Among others, the following article helped me understand the problem: <a href="http://www.yoda.arachsys.com/csharp/plugin.html">Plug-ins and cast exceptions</a><br />I could check later that, as I was instantiating the library to load the auxiliar factory with <font color="#990000">Assembly.LoadFrom</font> at design time, I was loading it into the default application domain associated with the IDE process, and so this DLL was released only when you closed the IDE, thus having in memory many definitions apparently identical. I solved the problem loading the DLL into a separate application domain,<br />isolated, using <font color="#990000">AppDomain.LoadFrom</font> instead of <font color="#990000">Assembly.LoadFrom</font> and unloading the domain once used the factory. </p><li><p>For documenting the classes and methods, I have relied on the code comments and I have used <a href="http://docproject.codeplex.com/">DocProject</a>, tool built over <a href="http://sandcastle.codeplex.com/">Sandcastle - Documentation Compiler for Managed Class Libraries</a>. It is a very easy and powerful combination. In particular I have used version 1.11.0 Release Candidate of DocProject and Sandcastle May 2008 Release.</p></li></li></li></li></li></li></li></ul><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /><p /></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></p></li></p></summary>
    </member>
  </members>
</doc>